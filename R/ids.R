# Query to GeoSource service service ----
#' Build a search URL for the RSS service
#'
#' This internal helper constructs a URL to query the French Ministry
#' of Culture's "Atlas du Patrimoine" GeoSource service, filtered by a
#' bounding box (`extent`) and a department code (`insee_dep`).
#'
#' @param extent A named list with elements `left`, `bottom`, `right`, `top`
#' defining the bounding box coordinates.
#' @param insee_dep A character or numeric INSEE department code.
#'
#' @return A character string containing the full URL to query the GeoSource service.
#'
#' @keywords internal
#'
ids_build_url <- function(extent, insee_dep) {
  base_url <- "http://atlas.patrimoines.culture.fr/geosource/srv/fr/rss.search?"

  query_params <- list(
    "_dc" = as.character(as.numeric(Sys.time()) * 1000),
    from = 1,
    to = 30,
    sortby = "MCC",
    pertinentScaleLevel = 1,
    georss = "simple",
    westBL = extent$left,
    eastBL = extent$right,
    southBL = extent$bottom,
    northBL = extent$top,
    geoForm = "BBOX",
    geoID = paste0("DEP_", insee_dep),
    themekeywords = "Protection"
  )

  query_string <- paste(
    names(query_params),
    vapply(query_params, function(x) URLencode(as.character(x), reserved = TRUE), character(1)),
    sep = "=",
    collapse = "&"
  )

  proxy_url <- paste0(
    "http://atlas.patrimoines.culture.fr/atlas/trunk/proxy_ign.php?url=",
    URLencode(paste0(base_url, query_string), reserved = TRUE)
  )

  proxy_url
}


#' Perform the request URL to the GeoSource service
#'
#' This internal helper executes an HTTP GET request to the specified URL,
#' typically generated by [ids_build_url()], to retrieve data from the French
#' Ministry of Culture's "Atlas du Patrimoine" GeoSource service.
#' It includes a retry mechanism in case of connection failure.
#'
#' @param url `character`. The complete request URL to query, usually produced
#' by [ids_build_url()].
#' @param timeout `numeric`. Maximum duration (in seconds) for the request
#' before timing out. Default is `60`.
#'
#' @details
#' The function uses the **httr2** framework for HTTP requests.
#' If the first request attempt fails (e.g., due to network latency or server
#' issues), it waits for 5 seconds and retries once before returning `NULL`.
#'
#' Progress and error messages are displayed via `message()` and `warning()`.
#'
#' @return
#' A `httr2_response` object if the request succeeds, or `NULL` if both attempts
#' fail.
#'
#' @examples
#' \dontrun{
#' # Build a URL for a given extent and department
#' bbox <- list(left = -2.5, right = -1.0, bottom = 47.0, top = 47.8)
#' url <- ids_build_url(extent = bbox, insee_dep = "44")
#'
#' # Perform the HTTP request (returns a httr2_response object)
#' res <- ids_perform_request(url)
#' }
#'
#' @seealso [ids_build_url()] for URL generation.
#'
#' @importFrom httr2 request req_timeout req_perform
#'
#' @keywords internal
#'
ids_perform_request <- function(url, timeout = 60) {
  # Build the httr2 request object with timeout
  req <- request(url) |> req_timeout(timeout)

  # Perform request with retry on error
  tryCatch(
    req_perform(req),
    error = function(e) {
      message("Connection failed, retrying in 5s...")
      Sys.sleep(5)
      tryCatch(
        req_perform(req),
        error = function(e) {
          warning("Final failure: ", e$message)
          return(NULL)
        }
      )
    }
  )
}

##' Parse the response from the RSS service
#'
#' This internal helper parses the XML response returned by [ids_perform_request()]
#' to extract and format dataset metadata items (IDs, titles and GUIDs) published
#' in the French Ministry of Culture's"Atlas du Patrimoine" GeoSource RSS service feed.
#'
#' @param res A `httr2_response` object, typically obtained from
#' [ids_perform_request()]. If `NULL` or invalid, an empty `data.frame` is returned.
#'
#' @details
#' The function reads the XML structure of the RSS feed and extracts all
#' `<item>` elements, retrieving their `title` and `guid` fields.
#' It also derives a simplified numeric identifier (`id`) from the `guid`
#' field when it follows the `"MD_XXXX"` pattern.
#'
#' This parsing step provides a lightweight summary of the available records
#' before any subsequent data download or processing.
#'
#' @return
#' A `data.frame` with the following columns:
#' \describe{
#'   \item{id}{Numeric identifier extracted from the GUID.}
#'   \item{title}{Record title as published in the GeoSource service.}
#'   \item{guid}{Full GUID (unique resource identifier).}
#' }
#' Returns an empty `data.frame` if the response is `NULL`, has a non-200 status,
#' or contains no items.
#'
#' @examples
#' \dontrun{
#' bbox <- list(left = -2.5, right = -1.0, bottom = 47.0, top = 47.8)
#' url  <- ids_build_url(extent = bbox, insee_dep = "44")
#' res  <- ids_perform_request(url)
#' df   <- ids_parse_response(res)
#' head(df)
#' }
#'
#' @seealso [ids_build_url()] for URL construction, [ids_perform_request()] for HTTP request execution.
#'
#' @importFrom httr2 resp_status resp_body_string
#' @importFrom xml2 read_xml xml_find_all xml_text
#' @importFrom utils head
#'
#' @keywords internal
#'
ids_parse_response <- function(res) {
  # Return empty data.frame if response is NULL or status is not 200
  if (is.null(res) || httr2::resp_status(res) != 200) return(data.frame())

  # Read XML content from response
  xml_txt <- resp_body_string(res)
  doc <- read_xml(xml_txt)

  # Extract <item> nodes
  items <- xml_find_all(doc, ".//item")
  if (length(items) == 0) return(data.frame())

  # Extract titles and GUIDs
  titles <- xml_text(xml_find_all(items, "./title"))
  guids  <- xml_text(xml_find_all(items, "./guid"))

  # Extract numeric IDs from GUIDs following the MD_XXXX pattern
  ids <- sub(".*MD_([0-9]+).*", "\\1", guids)

  # Return formatted data.frame
  data.frame(
    id = ids,
    title = titles,
    guid = guids,
    stringsAsFactors = FALSE
  )
}

#' Fetch layers items from a given URL
#'
#' This internal function performs an HTTP request to the URL (usually
#' generated by [ids_build_url()]), parses the response, and returns
#' a data.frame of heritage items with their IDs and titles.
#'
#' @param url Character. The request URL to query.
#' @param id Character. Optional ID for reporting purposes in verbose mode.
#' @param verbose Logical. Whether to print messages when no results are found.
#'
#' @return A data.frame with columns `id`, `title`, and `guid`.
#' Returns an empty data.frame if the request fails or no items are found.
#'
#' @keywords internal
#'
ids_fetch <- function(url, id = NA_character_, verbose = FALSE) {
  # Perform the request
  res <- ids_perform_request(url)

  # Parse the response
  df <- ids_parse_response(res)

  # Verbose message if no results
  if (nrow(df) == 0 && verbose) {
    message(sprintf("No result for ID %s", id))
  }

  df
}

#' Determine internal codes from IDs titles
#'
#' This internal function converts IDs tiles into their corresponding
#' internal codes (e.g., "IMMH", "PAMH").
#' It matches based on predefined keyword patterns and chooses the most
#' specific code when multiple patterns match.
#'
#' @param x `character` vector of IDs titles.
#'
#' @return `character` vector of internal codes corresponding to each input IDs titles.
#' Returns `NA` if no pattern matches.
#'
#' @keywords internal
#'
ids_to_codes <- function(x) {
  # Define patterns associated with each heritage code
  patterns <- list(
    IMMH = c("Immeubles classés ou inscrits"),
    PAMH = c("Protection au titre des abords de monuments historiques",
             "Abord d'un monument historique"),
    IMDN = c("Domaines nationaux"),
    PADN = c("Protection au titre des abords de domaines nationaux"),
    IMUN = c("Emprise surfacique des biens",
             "Périmètre des biens inscrits",
             "Patrimoine Mondial UNESCO - Bourgogne-Franche-Comté"),
    PAUN = c("Emprise surfacique de la zone tampon des biens"),
    SICI = c("Sites classés ou inscrits",
             "Site classé",
             "Site inscrit",
             "Sites inscrits",
             "Sites classés",
             "Sites classé ou inscrit"),
    SIPR = c("Sites Patrimoniaux Remarquables",
             "Sites patrimoniaux remarquables",
             "Site Patrimonial Remarquable"),
    ZPPA = c("Zones de présomption de prescription archéologique",
             "zones de présomption de prescription archéologique",
             "Zones de présomption de prescriptions archéologiques"),
    LACR = c("Architecture Contemporaine Remarquable",
             "Architecture contemporaine remarquable")
  )

  # Internal helper to find the best matching code for a given description
  find_code <- function(text) {
    matches <- character(0)
    matched_lengths <- integer(0)

    for (code in names(patterns)) {
      pats <- patterns[[code]]
      hit <- sapply(pats, grepl, text, ignore.case = TRUE)
      if (any(hit)) {
        # Keep track of matching code and length of the longest matching pattern
        longest <- max(nchar(pats[hit]))
        matches <- c(matches, code)
        matched_lengths <- c(matched_lengths, longest)
      }
    }

    if (length(matches) == 0) return(NA_character_)
    # Select the code with the longest matching pattern (more specific)
    matches[which.max(matched_lengths)]
  }

  # Apply to each element of the input vector
  sapply(x, find_code, USE.NAMES = FALSE)
}

#' Batch fetch heritage items for multiple entities
#'
#' This internal function iterates over rows of a data.frame (or sf object),
#' calls `get_heritage_ids()` for each row, and aggregates results.
#' It includes a pause between requests to avoid overloading the server.
#'
#' @param x Data.frame or sf object. Each row represents an entity to query.
#' @param sleep_time Numeric. Pause (in seconds) between successive requests. Default is 10.
#' @param verbose Logical. Whether to print progress messages. Default is TRUE.
#'
#' @return A data.frame combining all non-null results from `get_heritage_ids()`.
#'
#' @keywords internal
#'
ids_batch <- function(x, sleep_time = 10, verbose = TRUE) {
  n <- nrow(x)
  results <- vector("list", n)

  for (i in seq_len(n)) {
    if (verbose) {
      message(sprintf("[%d/%d] Processing entity %d...", i, n, i))
    }

    # Select the i-th entity
    x_i <- x[i, ]

    # Attempt to fetch heritage IDs
    res <- try(get_heritage_ids(x_i, verbose = verbose), silent = TRUE)

    # Store result or report error
    if (inherits(res, "try-error")) {
      warning(sprintf("Error on entity %d: %s", i, attr(res, "condition")$message))
      results[[i]] <- NULL
    } else {
      results[[i]] <- res
    }

    # Pause between requests
    if (i < n) Sys.sleep(sleep_time)
  }

  # Combine non-null results
  ids_final <- do.call(rbind, results[!vapply(results, is.null, logical(1))])
  ids_final
}
